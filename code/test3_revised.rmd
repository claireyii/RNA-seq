---
title: "test2"
author: "Claire Man"
date: "4/7/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load Data and Packages
```{r results = 'hide', message = FALSE, warning = FALSE}
library(SingleCellExperiment)
library(scater)
library(slingshot)
library(tradeSeq)
library(mclust, quietly = TRUE)
library(RColorBrewer)
library(remotes)
library(readr)
library(stats)
load("../data/se_paul.rda")
```
  
  
## Upstream Analysis  
```{r}
set.seed(21)
# Change count matrix from a dgcmatrix back into a normal matrix. 
counts(se) <- as.matrix(counts(se))

# Add another assay called logcounts
se <- logNormCounts(se)

# Add PCA and UMAP results in reducedDim
se <- runUMAP(se)
se <- runPCA(se, ncomponents = 15)

# Compute reduced dim matrix
rd <- reducedDim(se, "PCA")

# Clustering
cl <- kmeans(rd, 7)$cluster

# Add kmeans to colData (names)
se$kmeans <- cl

# Plot based on UMAP by kmeans clustering
jpeg('../images/UMAP_kmeans.jpg')
plotReducedDim(se, dimred = "UMAP", colour_by = "kmeans")
dev.off()

# Plot based on UMAP by cell type clustering
jpeg('../images/UMAP_celltype.jpg')
plotReducedDim(se, dimred = "UMAP", colour_by = "cell_type2") 
dev.off()

se <- runPCA(se)
# Plot based on PCA by kmeans clustering
jpeg('../images/PCA_kmeans.jpg')
plotReducedDim(se, dimred = "PCA", colour_by = "kmeans")
dev.off()

# Plot based on PCA by cell type clustering
jpeg('../images/PCA_celltype.jpg')
plotReducedDim(se, dimred = "PCA", colour_by = "cell_type2") 
dev.off()
```
  
  
## Slingshot  
```{r}
# Run slingshot, colData now has slingPseudotime_1 in it
se <- slingshot(se, clusterLabels = "kmeans", reducedDim = "PCA", start.clus = 3)

# Plot PCA with fitting curve
jpeg('../images/PCA.jpg')
plot(reducedDims(se)$PCA, col = brewer.pal(9, "Set1")[se$kmeans], pch = 16, asp = 1)
dev.off()

jpeg("../images/PCA_Sling.jpg")
plot(reducedDims(se)$PCA, col = brewer.pal(9, "Set1")[se$kmeans], pch = 16, asp = 1)
lines(SlingshotDataSet(se), lwd = 3, col = "black")
dev.off()
```
  
  
## Fit GAM

```{r}
# sce <- fitGAM(counts = se, genes = 1:20)
# saveRDS(sce, file = "fitGAM_output.rds")
GAM <- read_rds("../data/fitGAM_output.rds")
```
  
```{r}
predictions <- predictSmooth(GAM, gene = 1:20, nPoints = 40) 
```
  
  
## Curves

```{r}
# Extract the curve objects
sds <- SlingshotDataSet(se)
```
  
**Principle Curve**: Fits a principal curve which describes a smooth curve that passes through the middle of the data x in an orthogonal sense. 
Arguments: x - a mtrix of points in arbitrary dimension. 

```{r}
# Send it back to the count space
head(sds@curves$curve1$s)

# ?prcomp
# Compute the first 15 principal components
pca <- prcomp(t(logcounts(se)), rank. = 15, scale = FALSE)
pca2 <- prcomp(t(logcounts(se)), center = FALSE, scale = FALSE)

# eigenvalues
length(pca$sdev^2)

# projection of the cells in the reduced dimension space
dim(pca$x)

# matrix where the columns are the eigenvectors
dim(pca$rotation)
```

```{r}
low_to_high2 <- function(dat, pca, replaced_x) {
  mu <- colMeans(dat)
  pca <- prcomp(dat)
  
  ncomponents <- 15
  dat_hat <- replaced_x %*% t(pca$rotation)
  # dat_hat <- scale(dat_hat, center = -mu, scale = FALSE)

  return(dat_hat)
}

pca <- prcomp(t(logcounts(se)), center = FALSE, scale = FALSE)

new_count_matrix <- low_to_high2(t(logcounts(se)), pca, pca$x)
```


```{r}
# replace pca$x by sds@curves$curve1$s to get the new count matrix
low_to_high <- function(pca, replace_x) {
  return(replace_x %*% solve(pca$rotation))
}

new_count_matrix <- low_to_high(pca, pca$x)
dim(new_count_matrix)

# sanity check
check <- calculatePCA(new_count_matrix, ncomponents = 15)
head(check)
```